*init protocol step: confirmation
    * Client check & response
    * Server check and fsm advance

*Login:
    * Create unified message type (prefix, diff for serv&client
        +content, unified separators)
    * Make unified message checking (first check header, then parse content)
        * Impl in client, check init msg
        * Insert into sess
    * Send login&passwd to server
    * Parse and match with file server side

*Protocol remake:
    * Impl a netstring full msg
    * Fix problem: currently delimiter : still can not be inside a word
        * Remake message packing
        * Remake message parsing
    * Idea: make string lengths ints (not decimal strings), since there is max

*File list:
    * Make client dialogue with options (as of now -- simple)
    * Make client action & protocol request
    * Make server response
    * Parse out database and add names to the response
    * On parsing dirent check files (& load meta into memory?)
        * Write metafile parsing
        * On dirent parsing parse all .meta files & fill meta array
            * Test out all metas parsing
            * Test on bad directories
    * Pack filenames & descritions, send them out
    * Rewrite client frontend to display them
    * Add special * access modifier parsing in meta

*File query:
    * Make protocol request
    * Recieve serverside
    * Lookup file
    * If not good, send reply (no file/no access) (currently only no file)

*Login remake:
    * Remake passwd to in-mem storage
        * Check passwd f for correctness
    * Add username field to session (NULL = not logged in)
    * Update file query as to check privileges
    * Update file list as to only display avalilable files
    * Make login one of the actions & optional

*File transfer:
    * Implement buf for client & partial reading for both client and server
    * Send out file length or num packets in start-transfer message
    * Add session state & start streaming file immediately
    * Create file & recieve->write client side
        * DEBUG: stage: bad packet
    * Test cutting up
    * Fix the free bug in protocol::store_word
        * The problem: new p_add and free together cause freeing of invalid pointer
            separately they are good

*Leave message:
    * Make leave-message client action & dialogue (with max message len)
    * Make message file, and db_init message file checking (enties: user\n msg\n\n), if not present -- create
    * Serverside upon recieving a message put it in the messages.txt file

Refac:
    * Sort out the error scenarios in client
    * Go through in-code todos
    - Refactor db stuff & db todos
    - Go through client.c todos
    - Add error messages to client (and server?) for special situations
    - Remake all sizeof() to *var, instead of type (fucked me up hard with byte_arr)
    - Refactor byte_arr usage accross protocol, client and server
    - Brush up client ui (new lines & prettiness)
    - Make a distinct name for message to admin (not to collide with message)
    - Freestyle refac pass

Other:
    * Make title a bbs property & send with init msg
    - Remake file i/o on transfer to read/write for optimization
    - Add download progress bar to client (in packets, redraw with \b)

Disconnections, timeouts & exceptional situations
    - Idea: Add file status to metafile (valid, writing, corrupted), for disconnections when loading file
    - Idea: implement timeouts for pending packages
    - Idea: need to check eof if sock (=disconnected)
    - Idea: implement (^C) interception as regular exit, and send disconnection message
    - Thought: I should really understand how to deal with invalid packets and parsing client side (now, I just kill the client)

Admin user:
